\documentclass[10pt]{beamer}

\usetheme[progressbar=frametitle]{metropolis}
\usecolortheme{aggie}

\usepackage{tikz}
\usepackage[compatibility=false]{caption}
\usepackage{subcaption}
\usepackage{graphicx}
\graphicspath{{img/}}
\usepackage{appendixnumberbeamer}

\usepackage{booktabs}
\usepackage[scale=2]{ccicons}
\usepackage[style=authoryear-comp,backend=biber]{biblatex}
%== use and define color ==%
\AtEveryCite{\color{blue}}
\addbibresource{references.bib}

\usepackage{pgfplots}
\usepackage{amsmath}
\usepackage{bm}
\usepackage{listings}
\lstset{frame=tb,
language=R,
keywordstyle=\color{blue},
alsoletter={.}
}
\usepgfplotslibrary{dateplot}

% Customize footline to include current and total slide numbers
\makeatletter

\setbeamertemplate{footline}{
  \begin{tikzpicture}[remember picture,overlay]
    % Utiliser un compteur pour sélectionner différentes images avec modulo
    \pgfmathtruncatemacro{\imageindex}{mod(\thepage-1,10)+1}
    \node[anchor=south west, inner sep=0pt] at (current page.south west) {
      % Insérer l'image à gauche
      \includegraphics[height=0.75cm]{img/footer/image\imageindex}
    };
    \node[anchor=south east, inner sep=0pt] at (current page.south east) {
      % Vous pouvez également ajouter d'autres éléments à droite du pied de page si nécessaire
      \ifnum\c@framenumber>1%
      \hfill%
      {\fontsize{10}{12}\selectfont % Adjust the font size here
      \color{gray}%
      \raisebox{0pt}[\height-10pt][\depth]{\insertframenumber/\inserttotalframenumber}
      }%
    \fi%
    };
  \end{tikzpicture}

}
\makeatother

\usepackage{xspace}
\newcommand{\themename}{\textbf{\textsc{metropolis}}\xspace}

\title{Projet: ANOVA Phylogénétique}
\subtitle{Présentation du Mardi 26 Mars. 2024}
\date{}
\author{Alizée Geffroy, Louis Lacoste, encadrés par Mélina Gallopin et Paul Bastide}
\institute{M2 MathSV Université Paris-Saclay}
% \titlegraphic{\hfill\includegraphics[height=1.5cm]{logo.pdf}}

\begin{document}

\maketitle

<<'init', include=FALSE>>=
  knitr::opts_knit$set(fig.align = "center", warnings = FALSE, echo = FALSE, format = "latex")
  require("knitr", quietly = TRUE)
  options(knitr.table.format = "latex")
@

<<'libraries', include=FALSE>>=
# "phytools", "phylotools"
necessary_packages <- c("ape", "here")

if (any(!(necessary_packages %in% installed.packages()))) {
    install.packages(necessary_packages)
}

require(ape)
require(here)


source(here("R","utils.R"))
@

\begin{frame}{Sommaire}
  \setbeamertemplate{section in toc}[sections numbered]
  \tableofcontents[hideallsubsections]
\end{frame}

\begin{frame}[allowframebreaks]{Idée structure}
  TODO Supprimer cette slide temporaire
  \begin{itemize}
    \item \textbf{Intro/Contexte} : biologique avec l'exemple de Chen (mettre l'arbre) + figure de l'article ? -> trouver les gènes différentiellement exprimés
    \item Il existe déjà des méthodes statistiques pour cette problématique (EVEmodel ? State of the Art)
    \item Transition avec le pourquoi du projet, trouver d'autres méthodes statistiques, adaptées de méthodes classiques qui pourraient bien marcher
    \item \textbf{Méthode pas par nous} : 1 slide par tiret
    \begin{itemize}
        \item Reprendre la forme matricielle de l'ANOVA phylo (mettre en rouge les diffs)
        \item Présenter le MB qui évolue sur l'arbre + lien matrice K
        \item Mettre la statistique de test (mettre en rouge la projection (donc diffs))
    \end{itemize}
    \item Transition vers notre travail
    \begin{itemize}
        \item Mettre la formule avec erreur de mesure avec justification de l'ajout de l'erreur de mesure, formule transfo $V_{\lambda}$, pointer la limite qui est l'erreur dûe à l'estimation du $\lambda$
    \end{itemize}
    \item \textbf{Méthode par nous} :
    \begin{itemize}
        \item Satterthwaite : préciser que c'est nos calculs à partir de résultats sur modèle mixte (faire slide en appendice) + stat approximée + df formule une méthode possible parmi tant d'autres: Kenward Roger classique
    \end{itemize}
    \item \textbf{Simulations} :
    \begin{itemize}
        \item les 2 arbres avec les groupes
        \item Modalités de simulations, bien préciser que l'idée de simuler c'est pour voir erreur de type I et puissance
        \item Les résultats de simulations: pour les résultats Mettre ANOVA , ANOVA phylo Satterthwaite LRT
    \end{itemize}
    \item \textbf{Applications aux données réelles} :
    \begin{itemize}
        \item Rappel du type de données, RNA-seq sur pleins de gènes (éventuellement un extrait du tableau ?)
        \item Mentionner toutes les méthodes rapidement et présenter l'UpSet diagramme avec son analyse et la remarque sur Satterthwaite ML qui sur-sélectionne
    \end{itemize}
    \item \textbf{Conclusions/Ouvertures}:
    \begin{itemize}
        \item \textbf{Conclusions} :
        \begin{itemize}
            \item Récap du projet sur son contenu scientifique
        \end{itemize}
        \item \textbf{Ouvertures} :
        \begin{itemize}
            \item Utiliser un autre processus stochastique Ornstein-Uhlenbeck
            \item Comprendre pourquoi Satterthwaite a sur-sélectionné dans l'application: mauvaise implémentation ? évaluer l'impact de l'approx
            \item Prendre un autre arbre ou ré-échantillonner les groupes dans les simus
            \item Agrandir le cadre de simulations
            \item Appliquer les méthodes à d'autres données
            \item modèle qui fait gène par gène: imaginer en prenant tous les gènes : Limma
        \end{itemize}
    \end{itemize}
\end{itemize}




\end{frame}

\section[Introduction]{Introduction}

\begin{frame}[fragile]{Contexte biologique}
  \begin{figure}[H]
    \centering
    <<'plot-arbre-chen', out.width = "50%", echo = FALSE>>=
        tree <- read.tree(here("R","chen2019.tree"))
        # Normalising tree edge length
        taille_tree <- diag(vcv(tree))[1]
        tree$edge.length <- tree$edge.length / taille_tree

        phytools::plotTree(tree, ftype="i")
    @
    \caption{Arbre phylogénétique de \cite{chenQuantitativeFrameworkCharacterizing2019}}
    \label{fig:arbre-chen2019}
\end{figure}
intro/contexte: biologique avec l'exemple de Chen + figure de l'article ? 
trouver les gènes différentiellement exprimés
\end{frame}
\begin{frame}[fragile]{Mouvement brownien}
  \begin{figure}[H]
    \centering
  <<'plot-MB', warnings = FALSE, message = FALSE, out.width = "75%", fig.height = 3.5, echo = FALSE>>=
    source(here("simulations","mouvement_brownien.R"))
    set.seed(12)
    df <- generate_phylo_tree(5,100, 0.1)
    df$id_branche <- as.factor(df$id_branche)

    ggplot(df) +
        aes(x = time, y = traj, color = as.factor(id_branche))+
        geom_line() +
        # geom_vline(data = df[df$is_spec_time,], aes(xintercept = time, color = .data$id_branche), linetype = "dashed")+
        geom_point(data = df[df$is_spec_time,], aes(x = time, y = .data$traj), color = df[df$is_spec_time,]$id_branche, size = 4)+
        labs(color = "Espèce", x = "Temps", y = "Trait") +
        coord_fixed(ratio=0.75) +
        theme_minimal()
  @
\caption{Exemple d'un arbre phylogénétique dont le trait est généré selon un Mouvement Brownien}
  \end{figure}
\end{frame}

\begin{frame}
  Pour un trait Y mesuré chez des espèce i et j, $Cov(Y_i, Y_j)= \sigma^2t_{i,j}$ où $t_{i,j}$ est le temps d'évolution commune. 
  \begin{center}
    \includegraphics[width=0.7\textwidth]{matrix_K.png}
  \end{center}
  \footcite{bastideContinuousTraitEvolution2022}
\end{frame}
% \begin{frame}{partie maths}
% Le modèle de mouvement brownien va alors induire que les feuilles des arbres (nos observations) auront une distribution gausienne que l'on écrira sous la forme suivante
%   % Passer au brownien sur l'arbre donc la dérive mélange tout, le problème est 
%   % dur et présenter l'ANOVA phylogénétique 
% Le modèle le plus couramment utilisé pour ce type de données: Expression Variance and Evolution (EVE) modèle décrit dans \cite{rohlfsPhylogeneticANOVAExpression2015}

% Il suppose que les traits évoluent selon un 
% processus d'Ornstein-Uhlenbeck et le test réalisé est un \emph{Likelihood Ratio test} (LRT). 

% Notre projet s'inscrit dans un plus grand projet qui vise à trouver d'autres méthodes statistiques adaptées de méthodes classiques qui feraient aussi bien ou mieux
% \end{frame}

\section{État de l'art}
\begin{frame}{ANOVA phylogénétique}
  \begin{equation}
    Y = X\beta + u \text{, } u \sim \mathcal{N}_n(0, \textcolor{red}{\sigma^2_{phy}K})
    \label{eq:ANOVAphylo}
\end{equation}  
\[
    \text{où } \mathbf{Y} = \begin{bmatrix} Y_{11} \\\vdots\\ Y_{1n_1} \\ 
        Y_{21}\\ \vdots \\ Y_{2n_2} \end{bmatrix}\text{, } 
        \mathbf{X} = \begin{bmatrix} \mathbf{1} & \mathbf{1_{n_1}} \end{bmatrix}=\begin{bmatrix} 1 & 1 \\ \vdots & \vdots\\1 & 1 \\ 1 & 0\\ \vdots & \vdots\\1 & 0 \end{bmatrix} \text{, }  \mathbf{\beta} = \begin{bmatrix} \beta_1 \\ \beta_2  \end{bmatrix} \text{, } n=n_1+n_2
\]
% Au tableau pas oublier de dire \beta1 = \mu1, \beta2 = \mu1 - \mu2
\end{frame}


\begin{frame}{Statistique de test}
Pour $l=\begin{bmatrix}0 \\1 \end{bmatrix}$ :
\[ H_0 : \beta_2 =0 \Leftrightarrow l^T\beta = \begin{bmatrix}0 \\0\end{bmatrix} \text{, les 2 groupes ont la même moyenne}\]
\[ H_1 : \beta_2\neq 0 \text{, les 2 groupes ont des moyennes différentes}\]
On a alors la statistique de test suivante venant de \cite{bastideContinuousTraitEvolution2022} :   
\begin{equation}
    F_{ANOVAphylo}=\frac{||\hat{Y} - \bar{Y}||^2_{\textcolor{red}{K^{-1}}}(n-2)}{||Y - \hat{Y}||^2_{\textcolor{red}{K^{-1}}}} \underset{\mathcal{H}_0}{\sim}\mathcal{F}\text{isher} (1, n-2)
\end{equation}
\end{frame}

\begin{frame}{ANOVA phylogénétique et erreur de mesure}
  On ajoute une erreur de mesure qui correspond mieux à la réalité des données: erreur intraspécifique
\begin{equation}
    Y = X\beta + u + \epsilon \text{, } \quad u \sim \mathcal{N}_n(0, \sigma^2_{phy}K) \text{,} \quad \epsilon \sim \mathcal{N}_n(0, \sigma^2_{err}I_n)
\label{eq:eq2err}
\end{equation} 
En posant $\lambda = \frac{\sigma^2_{phy}}{\sigma^2_{err}}$ et $E=u+\epsilon$, on peut obtenir une nouvelle forme pour $Y$
\begin{align}
    \label{eq:V_lambda}
    &Y = X\beta + E \text{, où } Var(E)=V(\theta)=\sigma^2_{phy}(K-\lambda I_n)=\sigma^2_{phy}V_\lambda \\
    &E \sim \mathcal{N}_n(0, \sigma^2_{phy}V_\lambda) \notag
\end{align}
Problème: $\lambda$ n'est souvent pas connu et il faut l'estimer. Dans ce cas, l'approximation de la distribution de F par une distribution de Fisher ne tient plus

\end{frame}

\section{Calculs}
  \begin{frame}{Calcul avec approximation de Satterthwaite}
    Méthode pour approximer les véritables degrés de liberté quand $\lambda$ inconnu
    Pour cela on peur voir le modèle comme un modèle mixte
    \begin{align}
      &F_{approx}=\frac{||\hat{Y} - \bar{Y}||^2_{V_\lambda^{-1}}df_{approx}}{||Y - \hat{Y}||^2_{V_\lambda^{-1}}} \underset{\mathcal{H}_0}{\sim}\mathcal{F}\text{isher} (1, df_{approx})\\
      \text{Avec } &df_{approx} = \frac{2(f(\hat{\theta}))^2}{[\nabla f(\hat{\theta})]^T A[\nabla f(\hat{\theta})]} \\
      \text{où } &f(\theta) = l^TC(\theta)l \text{ et A matrice de variance-covariance de } \hat{\theta}=(\hat{\sigma}^2_{phy}, \hat{\sigma}^2_{err}) \notag
  \end{align}
    Satterthwaite : préciser que c'est nos calculs à partir de résultats sur modèle mixte (faire slide en appendice) 

  \end{frame}


\section{Simulations}
<<'modules-simulations', include = FALSE, eval=TRUE>>=
necessary_simu <- c("ape", "remotes", "phylolm", "phylolimma", "phytools", 
    "latex2exp", "here")

if (any(!(necessary_simu %in% installed.packages()))){
    install.packages(necessary_simu)
    remotes::install_github("lamho86/phylolm", quiet = TRUE)
    remotes::install_github("pbastide/phylolimma", quiet = TRUE)
}

library("ape")
library("phylolm")
library("phytools")
library("here")
library("tidyverse")
library("ggplot2")
library("patchwork")
library("latex2exp")
source(here("R","utils.R"))
@

<<'Import-arbre', include = FALSE>>=
K <- 2

nb_species <- 43

plot_group_on_tree <- function(tree, groups, ...) {
    plot(tree, ...)
    tiplabels(bg = groups, pch = 21, cex = 1.5)
}
tree <- read.tree(here("R","chen2019.tree"))
# Normalising tree edge length
taille_tree <- diag(vcv(tree))[1]
tree$edge.length <- tree$edge.length / taille_tree
@

<<'simus-groupes', include = FALSE>>=
seed <- 1234
set.seed(seed)
# Mus et Rat vs le reste
group_mus_rat_vs_other <- sapply(1:nb_species, function(tip) {
    if (tip %in% getDescendants(tree = tree, 55)) {
        return(1)
    }
    return(2)
})

rng_species <- c("chimp", "bonobo", "human", "orangutan", "marmoset", 
    "musMusculus", "rat", "dog", "ferret", "cow", "opossum")
random_groups <- rowSums(sapply(rng_species, 
    function(spec) grepl(spec, tree$tip.label)))
random_groups[random_groups == 0] <- 2
@

\begin{frame}[fragile, allowframebreaks]{Modalités de simulations}
  Afin d'avoir une idée des performances des méthodes, nous avons choisis de les
  comparer dans un contexte proche des cas d'application réels.

  \begin{figure}[H]
    \begin{subfigure}[H]{0.49\textwidth}
        \centering
        <<'plot-groupes-mus', echo = FALSE>>=
        plot_group_on_tree(tree, group = group_mus_rat_vs_other)
        @
        \caption{Groupes \emph{Mus} et rats contre les autres}
        \label{fig:simu-groupes-mus} 
    \end{subfigure}
    \hfill
    \begin{subfigure}[H]{0.49\textwidth}
        \centering
        <<'plot-groupes-random', echo = FALSE>>=
        plot_group_on_tree(tree, group = random_groups)
        @
        \caption{Groupes sélectionnés sans respect de la phylogénie.}
        \label{fig:simu-groupes-prop} 
    \end{subfigure}
    \caption{Arbre et groupes pour les simulations}
    \label{fig:arbres-groupes}
  \end{figure}

    <<'param-simulation', echo = FALSE>>=
    # Generate data for rat&mus vs the rest
    N <- 500
    risk_threshold <- 0.05

    ## Standardized parameters
    total_variance <- 1.0 # sigma2_phylo + sigma2_error, fixed [as tree_height = 1]
    heri <- c(0.3, 0.5, 0.7, 0.9) # heritability her = sigma2_phylo / total_variance. 0 means only noise. 1 means only phylo.
    snr <- 1 # signal to noise ratio snr = size_effect / total_variance
    @

Nous re-paramétrisons :

$$v_{tot} = \sigma^2_{phylo} + \sigma^2_{measure} = \Sexpr{total_variance}$$

Et alors les paramètres du modèle s'expriment :

  \begin{align*}
      \sigma^2_{phylo} &= h\times v_{tot},\\
      \sigma^2_{measure} &= (1-h) \times v_{tot} \\
  \end{align*}


Ainsi, $h = 0$ signifie qu'il y a seulement du bruit, et $h = 1$ 
seulement de l'information phylogénétique.

Et nous avons réalisé des simulations pour $h \in (\Sexpr{heri})$.
    
 % Choisir les figures que l'on veut mettre en valeur, les méthodes

 % Montrer les erreurs de type I
 % Pas présenter les ML
 % Enlever ANOVA phylo, Satterthwaite

 % Comparer ANOVA contre ANOVA phylo REML -> meilleur controle des faux positifs

 % Parler de Satterthwaite, ANOVA et ANOVA phylo

  % TODO faire retour sur 
  % La prise en compte de la structure de covariance même dans le groupe 
  % aléatoire aide car 2 espèce proches sont censées être proche et donc
  % si différentes on peut se dire qu'ils sont bien différent, l'ANOVA phylo
  % a un problème plus facile.


%  Couper en deux : ANOVA vs ANOVA phylo
%  ANOVA phylo vs Sattertwhaite
%  Satterthwaite vs LRT
\end{frame}
\begin{frame}[fragile]{Résultats: Erreur de type I}
  Add erreur de type 1 pour comparer que ça avec Satterthwaite REML, ANOVA et ANOVA phylo REML 
  \begin{figure}[H]
    \begin{subfigure}[H]{0.49\textwidth}
        \centering
        <<'typeI-data-plot-h01', echo = FALSE>>=
          her <- 0.3
          filename <- here("data", "simus", 
            paste0("real_her_", her, "_seed_", seed, ".Rds"))
          sim <- readRDS(filename)

          df_sim_plot <- compute_power_typeI(df = sim)
          head(df_sim_plot)
        @
        \caption{}
        \label{fig:simu-errI-h03} 
    \end{subfigure}
    \hfill
    \begin{subfigure}[H]{0.49\textwidth}
        \centering
        <<'typeI-data-plot-h09', echo = FALSE>>=
          her <- 0.9
          filename <- here("data", "simus", 
            paste0("real_her_", her, "_seed_", seed, ".Rds"))
          sim <- readRDS(filename)
        @
        \caption{}
        \label{fig:simu-errI-h09} 
    \end{subfigure}
    \caption{Erreurs de type I pour $h \in \{0.3 ; 0.9\}$}
    \label{fig:simu-errI}
  \end{figure}

\end{frame}
\begin{frame}{Résultats: puissance}
  Comparer les puissances des méthodes principales

\end{frame}


\section{Application aux données réelles}
\begin{frame}{Rappel des données}
  Nous allons appliquer les différentes méthodes aux données compilées par 
  \cite{chenQuantitativeFrameworkCharacterizing2019}. Il s'agit de données de 
  RNA-seq chez 17 espèces et de l'arbre phylogénétique présenté 
  figure~\ref{fig:arbre-chen2019}.
\end{frame}
\begin{frame}[fragile]{UpSet diagram}
  << 'knitr_options', echo = FALSE>>=
knitr::opts_knit$set(fig.pos = "HT", fig.width = 6, fig.height = 6,
    fig.align = "center", echo = FALSE, format = "latex")

@

<< import_modules, echo = FALSE, include=FALSE>>=
necessary_packages <- c("phylotools", "phytools", "phylolm", "limma", "edgeR", 
    "here", "ggplot2", "patchwork", "dplyr", "tidyr", "evemodel", 
    "compcodeR", "mvSLOUCH", "ComplexUpset", "see")

if (!all(necessary_packages %in% installed.packages())) {
    install.packages(necessary_packages)
    install.packages("remotes")
    remotes::install_gitlab("sandve-lab/evemodel")
    remotes::install_github("pbastide/compcodeR", ref = "phylolimma")
}

require(phylotools)
require(phytools)
require(phylolm)
require(limma)
require(edgeR)
require(here)
require(ggplot2)
require(dplyr)
require(tidyr)
require(ComplexUpset)
require(see)
require(evemodel)
require(compcodeR)
require(mvSLOUCH)
require(patchwork)


source(here("R","utils.R"))
@

<< import_donnees, echo = FALSE>>=
### Data import
cdata <- readRDS(here("data", "data_TER", "data", "chen2019_rodents_cpd.rds"))
is.valid <- compcodeR:::check_phyloCompData(cdata)
if (!(is.valid == TRUE)) stop("Not a valid phyloCompData object.")

# Design
design_formula <- as.formula(~condition)
design_data <- compcodeR:::sample.annotations(cdata)[, "condition", drop = FALSE]
design_data$condition <- factor(design_data$condition)
design <- model.matrix(design_formula, design_data)

# Normalisation
nf <- edgeR::calcNormFactors(compcodeR:::count.matrix(cdata) / compcodeR:::length.matrix(cdata), method = "TMM")
lib.size <- colSums(compcodeR:::count.matrix(cdata) / compcodeR:::length.matrix(cdata)) * nf
data.norm <- sweep((compcodeR:::count.matrix(cdata) + 0.5) / compcodeR:::length.matrix(cdata), 2, lib.size + 1, "/")
data.norm <- data.norm * 1e6

# Transformation
data.trans <- log2(data.norm)
rownames(data.trans) <- rownames(compcodeR:::count.matrix(cdata))
@
  << calcul_pvaleurs, echo = FALSE, warning = FALSE>>=
### Pvalues computation
pvalues_data = "chen2019pvalues.Rds"
pvalues_adj_data = "chen2019pvaluesadj.Rds"
if (!file.exists(here("data",pvalues_data)) | !file.exists(here("data",pvalues_adj_data))){
#  computing pvalues vec for all genes
    pvalue_vec_vanilla <- sapply(seq(1, nrow(data.trans)), function(row_id) {
        trait <- data.trans[row_id, ]
        fit_phylo <- phylolm(trait ~ design_data$condition, phy = cdata@tree, measurement_error = TRUE)
        compute_vanilla_pvalue(fit_phylo)
    })

    pvalue_vec_vanilla <- setNames(pvalue_vec_vanilla, rownames(data.trans))

    pvalue_vec_vanilla_adj <- p.adjust(pvalue_vec_vanilla, method = "BH")

    pvalue_vec_vanilla.REML <- sapply(seq(1, nrow(data.trans)), function(row_id) {
        trait <- data.trans[row_id, ]
        fit_phylo <- phylolm(trait ~ design_data$condition, phy = cdata@tree, REML = TRUE, measurement_error = TRUE)
        compute_vanilla_pvalue(fit_phylo)
    })

    pvalue_vec_vanilla.REML <- setNames(pvalue_vec_vanilla.REML, rownames(data.trans))

    pvalue_vec_vanilla_adj.REML <- p.adjust(pvalue_vec_vanilla.REML, method = "BH")

    pvalue_vec_satterthwaite <- sapply(seq(1, nrow(data.trans)), function(row_id) {
        trait <- data.trans[row_id, ]
        fit_phylo <- phylolm(trait ~ design_data$condition, phy = cdata@tree, measurement_error = TRUE)
        compute_satterthwaite_pvalue(fit_phylo, tree = cdata@tree)
    })

    pvalue_vec_satterthwaite <- setNames(pvalue_vec_satterthwaite, rownames(data.trans))

    pvalue_vec_satterthwaite_adj <- p.adjust(pvalue_vec_satterthwaite, method = "BH")


    pvalue_vec_lrt <- sapply(seq(1, nrow(data.trans)), function(row_id) {
        trait <- data.trans[row_id, ]
        fit_phylo <- phylolm(trait ~ design_data$condition, phy = cdata@tree, measurement_error = TRUE)
        compute_lrt_pvalue(fit_phylo, tree = cdata@tree)
    })

    pvalue_vec_lrt <- setNames(pvalue_vec_lrt, rownames(data.trans))
    pvalue_vec_lrt_adj <- p.adjust(pvalue_vec_lrt, method = "BH")

    # REML
    pvalue_vec_satterthwaite.REML <- sapply(seq(1, nrow(data.trans)), function(row_id) {
        trait <- data.trans[row_id, ]
        fit_phylo <- phylolm(trait ~ design_data$condition, phy = cdata@tree, REML = TRUE, measurement_error = TRUE)
        compute_satterthwaite_pvalue(fit_phylo, tree = cdata@tree)
    })

    pvalue_vec_satterthwaite.REML <- setNames(pvalue_vec_satterthwaite.REML, rownames(data.trans))

    pvalue_vec_satterthwaite_adj.REML <- p.adjust(pvalue_vec_satterthwaite.REML, method = "BH")


    ## Préparation du dataframe
        pvalues_adj_dataframe <- data.frame(
        gene = rep(rownames(data.trans), 5),
        pvalue = c(pvalue_vec_vanilla_adj,
            pvalue_vec_vanilla_adj.REML,
            pvalue_vec_satterthwaite_adj, 
            pvalue_vec_lrt_adj, 
            pvalue_vec_satterthwaite_adj.REML),
        test_method = rep(c( "ANOVA Phylo Ajustée", "ANOVA Phylo REML Ajustée",
        "ANOVA Phylo Satterthwaite Ajustée", "LRT Ajusté",
        "ANOVA Phylo Satterthwaite REML Ajustée"), each = nrow(data.trans))
    )

    pvalues_dataframe <- data.frame(
        gene = rep(rownames(data.trans), 5),
        pvalue = c(pvalue_vec_vanilla,
            pvalue_vec_vanilla.REML,
            pvalue_vec_satterthwaite, 
            pvalue_vec_lrt, 
            pvalue_vec_satterthwaite.REML),
        test_method = rep(c( "ANOVA Phylo", "ANOVA Phylo REML",
        "ANOVA Phylo Satterthwaite", "LRT",
        "ANOVA Phylo Satterthwaite REML"), each = nrow(data.trans))
    )

    pvalues_dataframe$test_method <- as.factor(pvalues_dataframe$test_method)
    pvalues_dataframe <- pvalues_dataframe %>% mutate(selected = ifelse(pvalue < 0.05, 1, 0))

    pvalues_adj_dataframe$test_method <- as.factor(pvalues_adj_dataframe$test_method)
    pvalues_adj_dataframe <- pvalues_adj_dataframe %>% mutate(selected = ifelse(pvalue < 0.05, 1, 0))

    save(pvalues_dataframe, file = here("data", pvalues_data))
    save(pvalues_adj_dataframe, file = here("data", pvalues_adj_data))
} else {
    load(here("data", pvalues_data))
    load(here("data", pvalues_adj_data))
}
@
  <<'evemodel', echo = FALSE, warning = FALSE, include = FALSE>>=
eve_data = "evechen2019pvalues.Rds"
if (!file.exists(here("data", eve_data))){

    # TODO comparer avec le package evemodel, twothetatest
    # Comparer avec OU lrt
    # Arbre sans les replicats et les genes data
    # remotes::install_gitlab("sandve-lab/evemodel")
    # TODO Utiliser les infos de la ligne 83 du Rmd

    cdataEVE <- readRDS(here("data", "data_TER", "data", "chen2019_rodents_cpd.rds"))
    is.valid <- compcodeR:::check_phyloCompData(cdataEVE)
    if (!(is.valid == TRUE)) stop('Not a valid phyloCompData object.')
    tree_rep <- compcodeR:::getTree(cdataEVE)
    tree_norep <- compcodeR:::getTreeEVE(cdataEVE)
    theta_2_vec <- compcodeR:::getIsTheta2edge(cdataEVE, tree_norep)
    #col_species <- tree_norep$tip.label[compcodeR:::sample.annotations(cdataEVE)$id.species]
    col_species <- tree_norep$tip.label[cumsum(!duplicated(compcodeR:::sample.annotations(cdataEVE)$id.species))]

    # Normalisation
    nfEVE <- edgeR::calcNormFactors(compcodeR:::count.matrix(cdataEVE) / compcodeR:::length.matrix(cdataEVE), method = 'TMM')
    lib.sizeEVE <- colSums(compcodeR:::count.matrix(cdataEVE) / compcodeR:::length.matrix(cdataEVE)) * nfEVE
    data.normEVE <- sweep((compcodeR:::count.matrix(cdataEVE) + 0.5) / compcodeR:::length.matrix(cdataEVE), 2, lib.sizeEVE + 1, '/')
    data.normEVE <- data.normEVE * 1e6

    # Transformation
    data.transEVE <- log2(data.normEVE)
    rownames(data.transEVE) <- rownames(compcodeR:::count.matrix(cdataEVE))

    # Analysis with EVE
    evemodel.results_list <- evemodel::twoThetaTest(tree = tree_norep, gene.data = data.transEVE, isTheta2edge = theta_2_vec, colSpecies = col_species, upperBound  =  c(theta = Inf, sigma2 = Inf, alpha = log(2)/0.001/1))

    result.table <- data.frame(pvalue = pchisq(evemodel.results_list$LRT, df = 1, lower.tail = FALSE), logFC = compcodeR:::getlogFCEVE(evemodel.results_list$twoThetaRes, theta_2_vec, tree_norep))
    result.table$score <- 1 - result.table$pvalue
    result.table$adjpvalue <- p.adjust(result.table$pvalue, 'BH')

    rownames(result.table) <- rownames(compcodeR:::count.matrix(cdataEVE))

    evemodel_dataframe <- data.frame(gene = rep(rownames(result.table)), 
        pvalue = c(result.table$adjpvalue),
        test_method = rep("EVEAdj", each = nrow(result.table)))
    save(evemodel_dataframe, file = here("data", eve_data))
} else {
    load(file = here("data", eve_data))
}

evegenesNA <- (evemodel_dataframe%>% filter(is.na(pvalue)))$gene

evemodel_dataframe <- evemodel_dataframe %>% 
    filter(!is.na(pvalue)) %>% 
    mutate(selected = ifelse(pvalue < 0.05, 1, 0))

evemodel_dataframe$test_method <- as.factor(evemodel_dataframe$test_method)
@
  << pvalue_eve_upset, echo = FALSE>>=
    pvalueseve_dataframe <- rbind(pvalues_adj_dataframe, evemodel_dataframe)

    pvalueseve_dataframe_wide <- pvalueseve_dataframe  %>% 
        filter(test_method != "ANOVA Phylo Satterthwaite Ajustée") %>%
        pivot_wider(id_cols = gene,
        names_from = test_method, 
        values_from = selected, values_fill = 0) %>%
        data.frame()
  @

  \begin{figure}[H]
    \centering
    << full_plot, out.width = "70%",echo = FALSE>>=
    sets <- colnames(pvalueseve_dataframe_wide)[-1]
    sets_colors <- okabeito_colors()[-2][1:length(sets)]
    highlight_intersections <- lapply(seq_along(sets), function(i) {
        upset_query(set = sets[i], fill = sets_colors[i], color = sets_colors[i])
    })

    names(sets_colors) <- sets

    plot <- upset(pvalueseve_dataframe_wide, sets,
        name = "Méthode",
        width_ratio=0.1,
        base_annotations=list(
        # 'Intersection size'=intersection_size(),
        "Taille d'intersection" = intersection_size() + 
            scale_fill_venn_mix(
                data=pvalueseve_dataframe_wide,
                guide='none',
                colors=sets_colors
            )
        ),
        queries = highlight_intersections,
        set_sizes=(
            upset_set_size() +
            theme(axis.text.x=element_text(angle=90))
        )) 
    plot

    # upset(pvalueseve_dataframe_wide, 
    #     sets = sets,
    #     mainbar.y.label = "Nombre de gènes en commun",
    #     sets.x.label = "Nombre de gènes sélectionnés",
    #     sets.bar.color = sets_colors)
    @
    \caption{\emph{UpSet diagram} de toutes les méthodes en incluant la méthode EVE}
    \label{fig:venn-all-methods-eve}
\end{figure}
\end{frame}
\section{Conclusions et ouvertures}
\begin{frame}{Conclusions scientifiques}
  Récap du projet sur son contenu scientifique
\end{frame}
\begin{frame}{Problèmes rencontrés}
  \begin{itemize}
    \item Utilisation de l'approx de la Hessienne  -> expression analytique
  \end{itemize}
\end{frame}
\begin{frame}{Ouvertures}

  \begin{itemize}
    \item Utilisation du processus d'Ornstein-Uhlenbeck
    \item Pourquoi Satterthwaite a surselectionné ? Creuser 
    \item Prendre un autre arbre, autres données, ou ré-échantillonner les groupes dans les simus
    \item Modèle qui fait gène par gène: imaginer en prenant tous les gènes -> méthode LIMMA
  \end{itemize}
\end{frame}

\begin{frame}{Remerciements}

  Merci pour votre attention.


  Merci à nos encadrants pour leur accompagnement, leur disponibilité et 
  leur gentillesse.
\end{frame}

\section{Références et appendices}
\begin{frame}[allowframebreaks]{References}

    \printbibliography
  % \bibliographystyle{abbrv}

\end{frame}

\appendix

\begin{frame}[allowframebreaks]{Code pour les simulations}
Le code pour les simulations est disponible sur notre dépôt GitHub : \\
\begin{center}
    \url{https://github.com/Polarolouis/anova-phylogenetique-projet-msv/}
\end{center}
\end{frame}

\begin{frame}{Concernant les fautes d'orthographes}
  Après relecture du rapport, nous avons pu constater que celui-ci contenait de
  nombreuses coquille. Nous vous présentons nos excuses.
\end{frame}

\begin{frame}[allowframebreaks]{questions posables}
  - comment obtenir la stat de test pour anova phylo (Cholesky)
  - en quoi c'est un modèle mixte pour Satterthwaite ? 
  - calcul de la Hessienne optim vs formule analytique, mettre formule analytique
  - Le LRT un modèle emboité blabla ?
  - sur quoi est basé EVEmodel ?
  - Mettre la démo du calcul de la Hessienne
  - Ornstein Uhleinbeck : qu'est ce que ça change par rapport au MB ? EVE dit optimum qui saute pas le processus qui saute 
    Modélise deux niches différentes.
    Effet sur la moyenne masi ok , et sur la variance $K_\alpha$, ok pour satterthwaite masi prendre $\alpha$ en compte aussi 
    Modifie la structure de variance et ajoute un paramètre $\alpha$, $K(\alpha)$, un saut sur l'optima. 
  - données de comptage transformées donc ok de modéliser par MB
  
  En écologie ne travaille pas sur autant de traits, spécificité de la RNA-seq
  des milliers de données.

  LIMMA pour le cas non phylogénétique.
  Pour le cas phylogénétique \texttt{phylolimma}.
  
  Méthodes d'amélioration essayer de faire quelque chose qui prennent en compte
  plusieurs gènes à la fois
  - Est ce q'on pourrait faire une méthode comme LIMMA et faire Satterthwaite ?
  - c'est bizarre d'utiliser des mesures 

  Questions Mélina :
  - Qu’est qu’une ANOVA phylogénétique ? En quoi différent l’ ANOVA classique et l’ ANOVA phylogénétique ? 
  - Comment modéliser l’évolution d’un trait continu sur un arbre (choix du processus dans l’ANOVA phylogénétique : savoir qu’il existe différentes manières de faire, soit on prend un brownien, soit on prend un OU … )
  - Comment prendre en compte les erreurs de mesures dans l’anova phylogénétique ? (Car ici, dans le cadre de l’expression des gènes chez plusieurs espèces, on mesure plusieurs individus par espèce, on a donc une variabilité intra-espèce et une variabilité inter-espèces… il faut donc prendre en compte cela dans le modèle, et c’est d’ailleurs ce que fait EVE)
  - Quel test effectuer pour tester si on a une différence d’expression significative entre différent groupes d’espèces ? (LRT ou test basé sur la stat de Fisher).
  - Qu’est ce qu’un modèle mixte ? Comment estimer les paramètres dans un modèle mixte ? Quels tests stats ? Quel est le lien entre une anova phylo et un modèle mixte ?
  - Pourquoi faire du REML au du ML classique ? Dans quel context? 
  - Pour l'analyse de données réelles, vous avez également été confrontés à un problème de tests multiples : puisque vous faites un test par gènes, et que vous avez des milliers de gènes, alors vous devez "corriger les p-values" pour extraire votre sous liste de "gènes différentiellement exprimés" (deux approches classiques : Bonferroni / BH ) 

\end{frame}

\end{document}
